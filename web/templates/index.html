<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Mandeye Control</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" />
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/vue@3.4.21/dist/vue.global.prod.js"></script>
    <style>
      pre { white-space: pre-wrap; word-break: break-word; }
    </style>
  </head>
  <body>
    <div id="app" class="container py-4">
      <header class="d-flex justify-content-between align-items-center mb-3">
        <div class="d-flex align-items-center gap-2">
          <h1 class="h5 mb-0">Mandeye</h1>
          <span class="badge" :class="stateBadge">{{ status.state || 'Unknown' }}</span>
        </div>
        <div class="d-flex align-items-center gap-3">
          <div class="d-flex align-items-center" :class="lidarConnected ? 'text-success' : 'text-danger'">
            <i class="bi bi-bullseye"></i>
            <span class="ms-1">LiDAR</span>
          </div>
          <div class="d-flex align-items-center" :class="imuConnected ? 'text-success' : 'text-danger'">
            <i class="bi bi-compass"></i>
            <span class="ms-1">IMU</span>
          </div>
          <div v-if="gnssConnected" class="d-flex align-items-center text-success">
            <i class="bi bi-geo-alt"></i>
            <span class="ms-1">GNSS</span>
          </div>
          <div v-if="usbInfo" class="d-flex align-items-center text-success">
            <i class="bi bi-usb-drive"></i>
            <span class="ms-1">USB</span>
          </div>
          <div class="d-flex align-items-center" :class="online ? 'text-success' : 'text-danger'">
            <i :class="online ? 'bi bi-wifi' : 'bi bi-wifi-off'"></i>
            <span class="ms-1">Net</span>
          </div>
        </div>
      </header>

      <div v-if="error" class="alert alert-danger" role="alert" aria-live="assertive">{{ error }}</div>

      <div class="d-flex flex-wrap gap-3 align-items-center mb-3">
        <button class="btn btn-outline-secondary" @click="togglePause">
          {{ viewerPaused ? 'Resume Viewer' : 'Pause Viewer' }}
        </button>
        <div class="d-flex align-items-center gap-2">
          <label class="form-label mb-0 small">Chunk Duration</label>
          <select v-model="chunkDuration" class="form-select form-select-sm w-auto">
            <option v-for="opt in chunkOptions" :value="opt">{{ opt }}s</option>
          </select>
        </div>
        <select v-model.number="chunkDuration" @change="updateConfig" class="form-select w-auto">
          <option :value="10">10 s</option>
          <option :value="30">30 s</option>
          <option :value="60">60 s</option>
        </select>
        <select v-model.number="chunkSize" @change="updateConfig" class="form-select w-auto">
          <option :value="50">50 MB</option>
          <option :value="100">100 MB</option>
          <option :value="200">200 MB</option>
        </select>
      </div>

      <div class="row row-cols-1 row-cols-md-3 g-3">
        <div class="col" v-for="sys in systems" :key="sys.key">
          <div class="card h-100">
            <div class="card-header d-flex justify-content-between">
              <span>{{ sys.label }}</span>
              <span :class="['badge', systemConnected(sys) ? 'bg-success' : 'bg-danger']">
                {{ systemConnected(sys) ? 'Connected' : 'Disconnected' }}
              </span>
            </div>
            <div class="card-body">
              <pre v-if="systemConnected(sys)" class="mb-0">{{ format(status[sys.key]) }}</pre>
              <div v-else :class="sys.missingClass">{{ sys.missingMsg }}</div>
            </div>
          </div>

        <div v-if="usbInfo" class="ms-auto small">
          Output: {{ usbInfo.repository }} ({{ usbInfo.free_str }} free)

        </div>
      </div>

      <div class="row row-cols-1 row-cols-md-2 g-3 mt-2">
        <div class="col">
          <div class="card h-100">
            <div class="card-header">Scan Info</div>
            <div class="card-body">
              <p class="mb-1">Mode: {{ stream.mode || status.state || 'N/A' }}</p>
              <p class="mb-1">Elapsed: {{ Math.round((stream.dur||0)/1e9) }} s</p>
              <p class="mb-1">Last Saved File: {{ status.lastLazStatus && status.lastLazStatus.filename || 'N/A' }}</p>
              <p class="mb-1">Next Chunk: ~{{ (status.nextChunk && status.nextChunk.remaining_time_s || 0).toFixed(1) }} s / ~{{ (status.nextChunk && status.nextChunk.remaining_size_mb || 0).toFixed(1) }} MB</p>
              <p v-if="status.state && status.state.includes('ERROR')" class="text-danger fw-bold">Error: {{ status.state }}</p>
            </div>
          </div>
        </div>

        <div class="col">
          <div class="card h-100">
            <div class="card-header d-flex justify-content-between align-items-center">
              <span>Logs</span>
              <div class="d-flex gap-2 align-items-center">
                <select v-model="logFilter" class="form-select form-select-sm w-auto">
                  <option value="">All</option>
                  <option value="INFO">Info</option>
                  <option value="WARN">Warn</option>
                  <option value="ERROR">Error</option>
                </select>
                <button class="btn btn-sm btn-outline-secondary" @click="clearLogs">Clear</button>
              </div>
            </div>
            <pre id="logBox" class="bg-light p-2 small mb-0" style="max-height:200px; overflow-y:auto;">
              <div v-for="(l, idx) in filteredLogs" :key="idx" :class="logClass(l.level)">{{ l.raw }}</div>
            </pre>
          </div>
        </div>
      </div>
    </div>

    <script>
      const { createApp } = Vue;
      createApp({
        data() {
          return {
            status: {},
            stream: {},
            error: '',
            logs: [],
            logFilter: '',

            systems: [
              { key:'livox', label:'Lidar', missingMsg:'Lidar not detected', missingClass:'text-danger'},
              { key:'gnss', label:'GNSS', missingMsg:'GNSS not detected', missingClass:'text-danger'},
              { key:'fs', label:'Filesystem', missingMsg:'USB storage missing', missingClass:'text-warning'}
            ],
            chunkDuration: 10,
            chunkSize: 100

            viewerPaused: JSON.parse(localStorage.getItem('viewerPaused') || 'false'),
            chunkDuration: localStorage.getItem('chunkDuration') || '10',
            chunkOptions: ['10', '30', '60'],
            online: navigator.onLine

          };
        },
        computed: {
          filteredLogs() {
            if (!this.logFilter) return this.logs;
            return this.logs.filter(l => l.level === this.logFilter);
          },
          stateBadge() {
            const st = this.status.state || '';
            if (st.includes('ERROR')) return 'bg-danger';
            if (st.includes('SCAN')) return 'bg-success';
            if (st) return 'bg-info';
            return 'bg-secondary';
          },
          lidarConnected() {
            const data = this.status.livox;
            if (!data) return false;
            if (!data.init_success) return false;
            const ts = data?.LivoxLidarInfo?.timestamp_s;
            if (!ts) return false;
            return (Date.now() / 1000 - ts) < 5;
          },
          imuConnected() {
            const data = this.status.imu;
            if (!data) return false;
            if ('init_success' in data) return !!data.init_success;
            return Object.keys(data).length > 0;
          },
          gnssConnected() {
            const data = this.status.gnss;
            if (!data) return false;
            if ('init_success' in data) return !!data.init_success;
            return Object.keys(data).length > 0;
          },
          usbInfo() {
            const fs = this.status.fs?.FileSystemClient;
            if (!fs || !fs.mounted) return null;
            const free = fs.free_megabytes;
            if (typeof free === 'number' && free < 100) return null;
            return fs;
          }
        },
        watch: {
          viewerPaused(val) {
            localStorage.setItem('viewerPaused', JSON.stringify(val));
          },
          chunkDuration(val) {
            localStorage.setItem('chunkDuration', val);
          }
        },
        methods: {
          updateStatus() {
            if (this.viewerPaused) return;
            fetch('/api/status')
              .then(r => r.json())
              .then(data => { this.status = data; this.chunkDuration = data.chunk?.duration_s || this.chunkDuration; this.chunkSize = data.chunk?.size_mb || this.chunkSize; })
              .catch(err => {
                this.error = `Failed to fetch status: ${err.message}`;
                setTimeout(() => this.error = '', 3000);
              });
          },
          togglePause() {
            this.viewerPaused = !this.viewerPaused;
          },
          logClass(level) {
            return {
              ERROR: 'text-danger',
              WARN: 'text-warning',
              INFO: 'text-info'
            }[level] || 'text-body';
          },
          clearLogs() {
            this.logs = [];
          },
          updateConfig() {
            fetch('/api/config', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ chunk_size_mb: this.chunkSize, chunk_duration_s: this.chunkDuration })
            });
          }
        },
        mounted() {
          this.updateStatus();
          setInterval(() => { if (!this.viewerPaused) this.updateStatus(); }, 5000);

          const source = new EventSource('/api/stream');
          source.onmessage = e => {
            if (!this.viewerPaused) {
              try { this.stream = JSON.parse(e.data); } catch (err) {}
            }
          };
          source.onerror = () => {
            this.error = 'Stream connection lost';
            setTimeout(() => this.error = '', 3000);
          };

          const logSource = new EventSource('/api/logs');
          logSource.onmessage = e => {
            if (this.viewerPaused) return;
            const raw = e.data;
            const m = raw.match(/^\[(\w+)\]\s*(.*)$/);
            const level = m ? m[1] : 'INFO';
            const message = m ? m[2] : raw;
            this.logs.push({level, message, raw});
            if (this.logs.length > 200) this.logs.shift();
            this.$nextTick(() => {
              const box = document.getElementById('logBox');
              box.scrollTop = box.scrollHeight;
            });
          };
          logSource.onerror = () => {
            this.error = 'Log stream connection lost';
            setTimeout(() => this.error = '', 3000);
          };

          window.addEventListener('online', () => this.online = true);
          window.addEventListener('offline', () => this.online = false);
        }
      }).mount('#app');
    </script>
  </body>
</html>
